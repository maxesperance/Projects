# -*- coding: utf-8 -*-
"""The Score

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H05g4--Mrxxc7VSrvuyAEJPRJqAfxw1P

# **It's Time To Settle The Score**
"""

!pip install spotipy



# Commented out IPython magic to ensure Python compatibility.
#Import necessary packages
import numpy as np
import pandas as pd
from scipy.stats import iqr as sc
import statsmodels.api as sm

#visualizing
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from shapely.geometry import Point, Polygon
import plotly.express as px
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import seaborn as sns
import numpy as np
import seaborn as sns
sns.set()
# %matplotlib inline

#metrics and split
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

#model imports
from sklearn import linear_model
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import  ExtraTreesRegressor
from sklearn.cluster import KMeans
from xgboost import XGBRegressor
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import LassoCV
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LinearRegression, LassoCV, RidgeCV
from sklearn.metrics import mean_squared_error, r2_score

#create our credentials like clientid and client_secret as well as spotify object to access the API
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
client_id = "ef9f1ca18dc247e3acd1dfadc73781c2"
client_secret = "c5d066ae6103450d8ad05b7196da5074"
client_credentials_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

#Search For Artist
name = ["The Fugees"]
result = sp.search(name)
result['tracks']['items'][1]['artists']

#Extract Spotify albums
#Spotify URIs and album names in separate lists for later

#Extract Artist's uri
artists_uris = result['tracks']['items'][0]['artists'][0]['uri']
#Pull all of the artist's albums
artist_albums = sp.artist_albums(artists_uris, album_type='album')
#Store artist's albums' names' and uris in separate lists
artist_album_names = []
artist_album_uris = []
for i in range(len(artist_albums['items'])):
    artist_album_names.append(artist_albums['items'][i]['name'])
    artist_album_uris.append(artist_albums['items'][i]['uri'])

artist_album_names
artist_album_uris
#Keep names and uris in same order to keep track of duplicate albums

#Extract all the songs from every album

#loop through each album to extract key track data.

def album_songs(uri):
    album = uri
    spotify_albums[album] = {}
    #Create keys-values of empty lists inside nested dictionary for album
    spotify_albums[album]['album'] = []
    spotify_albums[album]['track_number'] = []
    spotify_albums[album]['id'] = []
    spotify_albums[album]['name'] = []
    spotify_albums[album]['uri'] = []
    #pull data on album tracks
    tracks = sp.album_tracks(album)
    for n in range(len(tracks['items'])):
        spotify_albums[album]['album'].append(artist_album_names[album_count])
        spotify_albums[album]['track_number'].append(tracks['items'][n]['track_number'])
        spotify_albums[album]['id'].append(tracks['items'][n]['id'])
        spotify_albums[album]['name'].append(tracks['items'][n]['name'])
        spotify_albums[album]['uri'].append(tracks['items'][n]['uri'])

#apply the function to each album URI in the list to pull the track data and create an empty dictionary called to store the spotify album data.
spotify_albums = {}
album_count = 0
for i in artist_album_uris: #each album
    album_songs(i)
    print(str(artist_album_names[album_count]) + " album songs has been added to spotify_albums dictionary")
    album_count+=1 #Updates album count once all tracks have been added

#Extract audio features for each song

#store the audio features of each album track and append the data into lists representing all the music tracks for that album we add additional key-values.

def audio_features(album):
    #Add new key-values to store audio features
    spotify_albums[album]['acousticness'] = []
    spotify_albums[album]['danceability'] = []
    spotify_albums[album]['energy'] = []
    spotify_albums[album]['instrumentalness'] = []
    spotify_albums[album]['liveness'] = []
    spotify_albums[album]['loudness'] = []
    spotify_albums[album]['speechiness'] = []
    spotify_albums[album]['tempo'] = []
    spotify_albums[album]['valence'] = []
    spotify_albums[album]['popularity'] = []

    track_count = 0
    for track in spotify_albums[album]['uri']:
        #pull audio features per track
        features = sp.audio_features(track)

        #Append to relevant key-value
        spotify_albums[album]['acousticness'].append(features[0]['acousticness'])
        spotify_albums[album]['danceability'].append(features[0]['danceability'])
        spotify_albums[album]['energy'].append(features[0]['energy'])
        spotify_albums[album]['instrumentalness'].append(features[0]['instrumentalness'])
        spotify_albums[album]['liveness'].append(features[0]['liveness'])
        spotify_albums[album]['loudness'].append(features[0]['loudness'])
        spotify_albums[album]['speechiness'].append(features[0]['speechiness'])
        spotify_albums[album]['tempo'].append(features[0]['tempo'])
        spotify_albums[album]['valence'].append(features[0]['valence'])
        #popularity is stored elsewhere
        pop = sp.track(track)
        spotify_albums[album]['popularity'].append(pop['popularity'])
        track_count+=1

#loop through albums extracting the audio features.add a random delay every few albums to avoid sending too many requests at Spotify's API.
import time
import numpy as np
sleep_min = 2
sleep_max = 5
start_time = time.time()
request_count = 0
for i in spotify_albums:
    audio_features(i)
    request_count+=1
    if request_count % 5 == 0:
        print(str(request_count) + " playlists completed")
        time.sleep(np.random.uniform(sleep_min, sleep_max))
        print('Loop #: {}'.format(request_count))
        print('Elapsed Time: {} seconds'.format(time.time() - start_time))

#add the above spotify music data to a new dataframe
#need to first organise our data into a dictionary to convert into a dataframe.
dic_df = {}
dic_df['album'] = []
dic_df['track_number'] = []
dic_df['id'] = []
dic_df['name'] = []
dic_df['uri'] = []
dic_df['acousticness'] = []
dic_df['danceability'] = []
dic_df['energy'] = []
dic_df['instrumentalness'] = []
dic_df['liveness'] = []
dic_df['loudness'] = []
dic_df['speechiness'] = []
dic_df['tempo'] = []
dic_df['valence'] = []
dic_df['popularity'] = []
for album in spotify_albums:
    for feature in spotify_albums[album]:
        dic_df[feature].extend(spotify_albums[album][feature])

len(dic_df['album'])

fugees = pd.DataFrame.from_dict(dic_df)
fugees

#save latest album in df
score = fugees[fugees.album== 'The Score (Expanded Edition)']
# Remove 'id' and 'uri' columns
score = score.drop(columns=['id', 'uri'])

# Sort descending order by column 'tempo'
score= score.sort_values(by='tempo', ascending=False)

score.head(5)

#Spotify has a duplicate issue which can be addressed by removing all but the most popular songs.

#print(len(soul))
#final_df = soul.sort_values('popularity', ascending=False).drop_duplicates('name').sort_index()
#print(len(final_df))

score.info()

score.shape

# Any missing data?
score.isnull().sum()

score.describe()

import plotly.graph_objects as go

# Define sound features and their values
sound_features = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', 'valence']
values = score[sound_features].mean()

# Create bar chart
fig = go.Figure()

fig.add_trace(go.Bar(
    x=sound_features,
    y=values,
    marker_color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'],  # Set custom colors
    opacity=0.75
))

# Update layout
fig.update_layout(
    title='Average Sound Features for "The Score (Expanded Edition)"',
    xaxis_title='Sound Features',
    yaxis_title='Average Value',
    showlegend=False
)

fig.show()

#Plot distribution of certain variables
fig=plt.figure(figsize=(20,12),facecolor='white')

plt.suptitle('Kane Distributions',weight='bold',fontsize='xx-large')

gs=fig.add_gridspec(2,2)

ax=[_ for i in range(4)]

ax[0]=fig.add_subplot(gs[0,0])
ax[1]=fig.add_subplot(gs[0,1])
ax[2]=fig.add_subplot(gs[1,0])
ax[3]=fig.add_subplot(gs[1,1])


sns.histplot(x="energy",data=score,ax=ax[0],shrink=0.5,bins=50,color="lightcoral")
sns.histplot(x="tempo",data=score,ax=ax[3],bins=20,color='red')
sns.boxplot(x='liveness',data=score,ax=ax[1],color='gold')
sns.violinplot(x="loudness",data=score,ax=ax[2],color="green")

for i in range(4):

    ax[i].set_yticklabels('')
    ax[i].set_ylabel('')
    ax[i].tick_params('y',length=0)

    for direction in ['top','left','right']:

        ax[i].spines[direction].set_visible(False)

import plotly.graph_objects as go

# Define sound features and their values
sound_features = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness', 'valence']
values = score[sound_features].mean().tolist()

# Create radar chart
fig = go.Figure()

fig.add_trace(go.Scatterpolar(
      r=values,
      theta=sound_features,
      fill='toself',
      name='Sound Features'
))

fig.update_layout(
  polar=dict(
    radialaxis=dict(
      visible=True,
      range=[0, 1]
    )),
  showlegend=False
)

fig.show()



#funnel plot of energy and instrumentalness
fig = px.funnel(score, x='track_number', y='energy', color='instrumentalness')
fig.show()

#energy
top_energy = score.nlargest(6, 'energy')

fig = px.bar(top_energy, x='track_number', y=['valence', 'energy', 'danceability', 'acousticness'], barmode='group')
fig.show()

#can you dance?
fig = px.scatter_3d(score, x='energy', y='danceability', z='acousticness',
              color='track_number')
fig.show()



#average speechiness
score.groupby(by='track_number')['speechiness'].mean()



from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Define features (X) and target variable (y)
features = ['energy', 'valence', 'danceability','acousticness','speechiness','instrumentalness']  # Add other relevant features here
X = score[features]
y = score['popularity']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and fit the linear regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print("Mean Squared Error:", mse)
print("R-squared:", r2)

